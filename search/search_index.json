{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pySemanticSlides API Documentation","text":""},{"location":"#slides.doi","title":"<code>doi</code>","text":"<p>Created on 2023-02-12</p> <p>@author: wf</p>"},{"location":"#slides.doi.DOI","title":"<code>DOI</code>  <code>dataclass</code>","text":"<p>get DOI data</p> Source code in <code>slides/doi.py</code> <pre><code>@dataclass\nclass DOI:\n    \"\"\"\n    get DOI data\n    \"\"\"\n    doi:str\n    debug:bool=False\n\n    def debug_dump(self,d:dict):\n        \"\"\"\n        dump the given dict if debug mode is on\n\n        Args:\n            d(dict): the dictionary to dump\n        \"\"\"\n        if self.debug:\n            print(json.dumps(d,indent=2))\n\n    def fetchMeta(self,headers:dict)-&gt;dict:\n        \"\"\"\n        get the metadata for my doi\n\n        Args:\n            headers(dict): the headers to use\n\n        Returns:\n            dict: the metadata according to the given headers\n        \"\"\"\n        url=f\"https://doi.org/{self.doi}\"\n        req=urllib.request.Request(url,headers=headers)\n        response=urllib.request.urlopen(req)\n        encoding = response.headers.get_content_charset('utf-8')\n        content = response.read()\n        text = content.decode(encoding)\n        return text\n\n    def fetchBibtexMeta(self)-&gt;dict:\n        \"\"\"\n        get the meta data for my  doi by getting the bibtext JSON \n        result for the doi\n\n        Returns:\n            dict: metadata\n\n        \"\"\"\n        headers= {\n            'Accept': 'application/x-bibtex; charset=utf-8'\n        }\n        text=self.fetchMeta(headers)\n        if self.debug:\n            print(text)\n        return text\n\n    def fetchCiteprocMeta(self)-&gt;dict:\n        \"\"\"\n        get the meta data for my  doi by getting the Citeproc JSON \n        result for the doi\n\n        see https://citeproc-js.readthedocs.io/en/latest/csl-json/markup.html\n\n        Returns:\n            dict: metadata\n        \"\"\"\n        headers= {\n            'Accept': 'application/vnd.citationstyles.csl+json; charset=utf-8'\n        }\n        text=self.fetchMeta(headers)\n        json_data=json.loads(text)\n        self.debug_dump(json_data)\n        return json_data\n\n    def fetchBibTexDict(self)-&gt;dict:\n        \"\"\"\n        get a latex BibTexDict for my doi\n\n        Returns:\n            dict: a dict with bibliographic metadata in bibtex latex format\n        \"\"\"\n        meta_bibtex=self.fetchBibtexMeta()\n        bd=bibtexparser.loads(meta_bibtex)\n        btex=None\n        if len(bd.entries)&gt;0:\n            btex=bd.entries[0]\n            self.debug_dump(btex)\n        return btex\n\n    def fetchPlainTextBibTexDict(self)-&gt;dict:\n        \"\"\"\n        get a plain text BibTexDict for my doi\n\n        Returns:\n            dict: a dict with bibliographic metadata in bibtex utf-8 (no latex) format\n        \"\"\"\n        btex=self.fetchBibTexDict()\n        if btex:\n            ln2t=LatexNodes2Text()\n            for key in btex:\n                latex=btex[key]\n                no_latex=ln2t.latex_to_text(latex)\n                btex[key]=no_latex\n            self.debug_dump(btex)\n        return btex\n</code></pre>"},{"location":"#slides.doi.DOI.debug_dump","title":"<code>debug_dump(d)</code>","text":"<p>dump the given dict if debug mode is on</p> <p>Parameters:</p> Name Type Description Default <code>d(dict)</code> <p>the dictionary to dump</p> required Source code in <code>slides/doi.py</code> <pre><code>def debug_dump(self,d:dict):\n    \"\"\"\n    dump the given dict if debug mode is on\n\n    Args:\n        d(dict): the dictionary to dump\n    \"\"\"\n    if self.debug:\n        print(json.dumps(d,indent=2))\n</code></pre>"},{"location":"#slides.doi.DOI.fetchBibTexDict","title":"<code>fetchBibTexDict()</code>","text":"<p>get a latex BibTexDict for my doi</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>a dict with bibliographic metadata in bibtex latex format</p> Source code in <code>slides/doi.py</code> <pre><code>def fetchBibTexDict(self)-&gt;dict:\n    \"\"\"\n    get a latex BibTexDict for my doi\n\n    Returns:\n        dict: a dict with bibliographic metadata in bibtex latex format\n    \"\"\"\n    meta_bibtex=self.fetchBibtexMeta()\n    bd=bibtexparser.loads(meta_bibtex)\n    btex=None\n    if len(bd.entries)&gt;0:\n        btex=bd.entries[0]\n        self.debug_dump(btex)\n    return btex\n</code></pre>"},{"location":"#slides.doi.DOI.fetchBibtexMeta","title":"<code>fetchBibtexMeta()</code>","text":"<p>get the meta data for my  doi by getting the bibtext JSON  result for the doi</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>metadata</p> Source code in <code>slides/doi.py</code> <pre><code>def fetchBibtexMeta(self)-&gt;dict:\n    \"\"\"\n    get the meta data for my  doi by getting the bibtext JSON \n    result for the doi\n\n    Returns:\n        dict: metadata\n\n    \"\"\"\n    headers= {\n        'Accept': 'application/x-bibtex; charset=utf-8'\n    }\n    text=self.fetchMeta(headers)\n    if self.debug:\n        print(text)\n    return text\n</code></pre>"},{"location":"#slides.doi.DOI.fetchCiteprocMeta","title":"<code>fetchCiteprocMeta()</code>","text":"<p>get the meta data for my  doi by getting the Citeproc JSON  result for the doi</p> <p>see https://citeproc-js.readthedocs.io/en/latest/csl-json/markup.html</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>metadata</p> Source code in <code>slides/doi.py</code> <pre><code>def fetchCiteprocMeta(self)-&gt;dict:\n    \"\"\"\n    get the meta data for my  doi by getting the Citeproc JSON \n    result for the doi\n\n    see https://citeproc-js.readthedocs.io/en/latest/csl-json/markup.html\n\n    Returns:\n        dict: metadata\n    \"\"\"\n    headers= {\n        'Accept': 'application/vnd.citationstyles.csl+json; charset=utf-8'\n    }\n    text=self.fetchMeta(headers)\n    json_data=json.loads(text)\n    self.debug_dump(json_data)\n    return json_data\n</code></pre>"},{"location":"#slides.doi.DOI.fetchMeta","title":"<code>fetchMeta(headers)</code>","text":"<p>get the metadata for my doi</p> <p>Parameters:</p> Name Type Description Default <code>headers(dict)</code> <p>the headers to use</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the metadata according to the given headers</p> Source code in <code>slides/doi.py</code> <pre><code>def fetchMeta(self,headers:dict)-&gt;dict:\n    \"\"\"\n    get the metadata for my doi\n\n    Args:\n        headers(dict): the headers to use\n\n    Returns:\n        dict: the metadata according to the given headers\n    \"\"\"\n    url=f\"https://doi.org/{self.doi}\"\n    req=urllib.request.Request(url,headers=headers)\n    response=urllib.request.urlopen(req)\n    encoding = response.headers.get_content_charset('utf-8')\n    content = response.read()\n    text = content.decode(encoding)\n    return text\n</code></pre>"},{"location":"#slides.doi.DOI.fetchPlainTextBibTexDict","title":"<code>fetchPlainTextBibTexDict()</code>","text":"<p>get a plain text BibTexDict for my doi</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>a dict with bibliographic metadata in bibtex utf-8 (no latex) format</p> Source code in <code>slides/doi.py</code> <pre><code>def fetchPlainTextBibTexDict(self)-&gt;dict:\n    \"\"\"\n    get a plain text BibTexDict for my doi\n\n    Returns:\n        dict: a dict with bibliographic metadata in bibtex utf-8 (no latex) format\n    \"\"\"\n    btex=self.fetchBibTexDict()\n    if btex:\n        ln2t=LatexNodes2Text()\n        for key in btex:\n            latex=btex[key]\n            no_latex=ln2t.latex_to_text(latex)\n            btex[key]=no_latex\n        self.debug_dump(btex)\n    return btex\n</code></pre>"},{"location":"#slides.keyvalue_parser","title":"<code>keyvalue_parser</code>","text":"<p>Created on 2023-02-14</p> <p>@author: wf</p>"},{"location":"#slides.keyvalue_parser.BaseKeyValueParser","title":"<code>BaseKeyValueParser</code>","text":"<p>general KeyValue Parser</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>class BaseKeyValueParser():\n    \"\"\"\n    general KeyValue Parser\n    \"\"\"\n\n    def __init__(self,config:KeyValueParserConfig):\n        \"\"\"\n        constructor\n\n        Args:\n            config(KeyValueParserConfig): the configuration to use\n        \"\"\"\n        self.config=config\n        self.errors=[]\n        self.keydefs_by_keyword={}\n\n    def setKeydefs(self,keydefs:typing.List[Keydef]):\n        \"\"\"\n        set my key definitions\n\n        Args:\n             keydefs(List[Keydef]): a list of keyword definitions\n        \"\"\"\n        self.keydefs_by_keyword=Keydef.as_dict(keydefs)\n\n    def add_error(self,error_msg:str):\n        \"\"\"\n        add the given error to my list of errors\n\n        Args:\n            error_msg(str): the error to add\n        \"\"\"\n        if self.config.debug:\n            print(error_msg)\n        self.errors.append(error_msg)\n\n    def handleErrors(self,text:str):\n        \"\"\"\n        handle my error with respect to the given text to pars\n        \"\"\"\n        if not self.config.ignore_errors:\n            error_str=\"\\n\".join(self.errors)\n            raise Exception(f\"key/value parsing of {text} failed with {len(self.errors)} errors:\\n{error_str}\")\n\n    def getStrippedValues(self,value_list)-&gt;list:\n        \"\"\"\n        strip all values in the given value list\n        \"\"\"\n        if not self.config.strip:\n            return value_list\n        else:\n            stripped_values=[]\n            for value in value_list:\n                stripped_values.append(value.strip())\n            return stripped_values\n</code></pre>"},{"location":"#slides.keyvalue_parser.BaseKeyValueParser.__init__","title":"<code>__init__(config)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>config(KeyValueParserConfig)</code> <p>the configuration to use</p> required Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def __init__(self,config:KeyValueParserConfig):\n    \"\"\"\n    constructor\n\n    Args:\n        config(KeyValueParserConfig): the configuration to use\n    \"\"\"\n    self.config=config\n    self.errors=[]\n    self.keydefs_by_keyword={}\n</code></pre>"},{"location":"#slides.keyvalue_parser.BaseKeyValueParser.add_error","title":"<code>add_error(error_msg)</code>","text":"<p>add the given error to my list of errors</p> <p>Parameters:</p> Name Type Description Default <code>error_msg(str)</code> <p>the error to add</p> required Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def add_error(self,error_msg:str):\n    \"\"\"\n    add the given error to my list of errors\n\n    Args:\n        error_msg(str): the error to add\n    \"\"\"\n    if self.config.debug:\n        print(error_msg)\n    self.errors.append(error_msg)\n</code></pre>"},{"location":"#slides.keyvalue_parser.BaseKeyValueParser.getStrippedValues","title":"<code>getStrippedValues(value_list)</code>","text":"<p>strip all values in the given value list</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def getStrippedValues(self,value_list)-&gt;list:\n    \"\"\"\n    strip all values in the given value list\n    \"\"\"\n    if not self.config.strip:\n        return value_list\n    else:\n        stripped_values=[]\n        for value in value_list:\n            stripped_values.append(value.strip())\n        return stripped_values\n</code></pre>"},{"location":"#slides.keyvalue_parser.BaseKeyValueParser.handleErrors","title":"<code>handleErrors(text)</code>","text":"<p>handle my error with respect to the given text to pars</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def handleErrors(self,text:str):\n    \"\"\"\n    handle my error with respect to the given text to pars\n    \"\"\"\n    if not self.config.ignore_errors:\n        error_str=\"\\n\".join(self.errors)\n        raise Exception(f\"key/value parsing of {text} failed with {len(self.errors)} errors:\\n{error_str}\")\n</code></pre>"},{"location":"#slides.keyvalue_parser.BaseKeyValueParser.setKeydefs","title":"<code>setKeydefs(keydefs)</code>","text":"<p>set my key definitions</p> <p>Parameters:</p> Name Type Description Default <code>keydefs(List[Keydef])</code> <p>a list of keyword definitions</p> required Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def setKeydefs(self,keydefs:typing.List[Keydef]):\n    \"\"\"\n    set my key definitions\n\n    Args:\n         keydefs(List[Keydef]): a list of keyword definitions\n    \"\"\"\n    self.keydefs_by_keyword=Keydef.as_dict(keydefs)\n</code></pre>"},{"location":"#slides.keyvalue_parser.KeyValueParser","title":"<code>KeyValueParser</code>","text":"<p>               Bases: <code>BaseKeyValueParser</code></p> <p>Key Value Parser (which won't handle all details properly) see https://stackoverflow.com/a/75270267/1497139</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>class KeyValueParser(BaseKeyValueParser):\n    \"\"\"\n    Key Value Parser (which won't handle all details properly)\n    see https://stackoverflow.com/a/75270267/1497139\n    \"\"\"\n\n    def __init__(self,config:KeyValueParserConfig):\n        \"\"\"\n        constructor\n\n        Args:\n            config(KeyValueParserConfig): the configuration to use\n        \"\"\"\n        BaseKeyValueParser.__init__(self, config)  \n        if config.record_delim==\"\\n\":\n            pp.ParserElement.setDefaultWhitespaceChars(\"\\t\")\n        else:\n            pp.ParserElement.setDefaultWhitespaceChars(\"\\n\")\n        pass\n\n\n    def setKeydefs(self,keydefs:typing.List[Keydef]):\n        \"\"\"\n        overwrite how to set my key definitions\n\n        Args:\n             keydefs(List[Keydef]): a list of keyword definitions\n        \"\"\"\n        BaseKeyValueParser.setKeydefs(self,keydefs)\n        # set local variable from config\n        record_delim=self.config.record_delim\n        key_value_delim=self.config.key_value_delim\n        value_delim=self.config.value_delim\n        quote=self.config.quote\n        #\n        # initialize grammar\n        # \n        # valid keys are alphas\n        g_key = pp.Word(pp.alphas)\n        # items may not have record or value delimiters or must be quoted\n        g_item = pp.OneOrMore(pp.Word(pp.printables+\" \"+self.config.unicode_chars, excludeChars=record_delim+value_delim+quote) | pp.QuotedString(quote_char=quote))\n        # a value is a value_delim delimited list of items\n        g_value = pp.delimited_list(g_item, delim=value_delim)\n        l_key_value_sep = pp.Suppress(pp.Literal(key_value_delim))\n        g_key_value = g_key + l_key_value_sep + g_value\n        self.g_grammar = pp.delimited_list(g_key_value, delim=record_delim)\n\n        g_key.add_parse_action(lambda x: \n            self.keydefs_by_keyword[x[0]].key if x[0] in self.keydefs_by_keyword else x\n        )\n        g_value.add_parse_action(lambda x: \n            [x] if len(x) &gt; 1 else x\n        )\n        g_key_value.add_parse_action(lambda x: \n            (x[0], x[1].as_list()) if isinstance(x[1],pp.ParseResults) else (x[0], x[1])\n        )\n        pass\n\n    def getKeyValues(self,text:str)-&gt;dict:\n        \"\"\"\n        get key/value pairs from the given text using the configured keys definition\n\n        Args:\n            text(str): the text to parser\n\n        Returns:\n            dict: the resulting key-value pairs\n        \"\"\"\n        self.errors=[]\n        key_values = dict()\n        if text:         \n            try:\n                for k,v in self.g_grammar.parse_string(text, parse_all=True):\n                    if self.config.strip:\n                        if isinstance(v,list):\n                            v=self.getStrippedValues(v)\n                        else:\n                            v=v.strip()\n                    key_values[k] = v\n            except Exception as ex:\n                tb = traceback.format_exc()\n                error_msg=f\"parsing {text} failed: \\n{str(ex)}\\n{tb}\"\n                self.add_error(error_msg)\n            self.handleErrors(text)\n        return key_values\n</code></pre>"},{"location":"#slides.keyvalue_parser.KeyValueParser.__init__","title":"<code>__init__(config)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>config(KeyValueParserConfig)</code> <p>the configuration to use</p> required Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def __init__(self,config:KeyValueParserConfig):\n    \"\"\"\n    constructor\n\n    Args:\n        config(KeyValueParserConfig): the configuration to use\n    \"\"\"\n    BaseKeyValueParser.__init__(self, config)  \n    if config.record_delim==\"\\n\":\n        pp.ParserElement.setDefaultWhitespaceChars(\"\\t\")\n    else:\n        pp.ParserElement.setDefaultWhitespaceChars(\"\\n\")\n    pass\n</code></pre>"},{"location":"#slides.keyvalue_parser.KeyValueParser.getKeyValues","title":"<code>getKeyValues(text)</code>","text":"<p>get key/value pairs from the given text using the configured keys definition</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the text to parser</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the resulting key-value pairs</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def getKeyValues(self,text:str)-&gt;dict:\n    \"\"\"\n    get key/value pairs from the given text using the configured keys definition\n\n    Args:\n        text(str): the text to parser\n\n    Returns:\n        dict: the resulting key-value pairs\n    \"\"\"\n    self.errors=[]\n    key_values = dict()\n    if text:         \n        try:\n            for k,v in self.g_grammar.parse_string(text, parse_all=True):\n                if self.config.strip:\n                    if isinstance(v,list):\n                        v=self.getStrippedValues(v)\n                    else:\n                        v=v.strip()\n                key_values[k] = v\n        except Exception as ex:\n            tb = traceback.format_exc()\n            error_msg=f\"parsing {text} failed: \\n{str(ex)}\\n{tb}\"\n            self.add_error(error_msg)\n        self.handleErrors(text)\n    return key_values\n</code></pre>"},{"location":"#slides.keyvalue_parser.KeyValueParser.setKeydefs","title":"<code>setKeydefs(keydefs)</code>","text":"<p>overwrite how to set my key definitions</p> <p>Parameters:</p> Name Type Description Default <code>keydefs(List[Keydef])</code> <p>a list of keyword definitions</p> required Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def setKeydefs(self,keydefs:typing.List[Keydef]):\n    \"\"\"\n    overwrite how to set my key definitions\n\n    Args:\n         keydefs(List[Keydef]): a list of keyword definitions\n    \"\"\"\n    BaseKeyValueParser.setKeydefs(self,keydefs)\n    # set local variable from config\n    record_delim=self.config.record_delim\n    key_value_delim=self.config.key_value_delim\n    value_delim=self.config.value_delim\n    quote=self.config.quote\n    #\n    # initialize grammar\n    # \n    # valid keys are alphas\n    g_key = pp.Word(pp.alphas)\n    # items may not have record or value delimiters or must be quoted\n    g_item = pp.OneOrMore(pp.Word(pp.printables+\" \"+self.config.unicode_chars, excludeChars=record_delim+value_delim+quote) | pp.QuotedString(quote_char=quote))\n    # a value is a value_delim delimited list of items\n    g_value = pp.delimited_list(g_item, delim=value_delim)\n    l_key_value_sep = pp.Suppress(pp.Literal(key_value_delim))\n    g_key_value = g_key + l_key_value_sep + g_value\n    self.g_grammar = pp.delimited_list(g_key_value, delim=record_delim)\n\n    g_key.add_parse_action(lambda x: \n        self.keydefs_by_keyword[x[0]].key if x[0] in self.keydefs_by_keyword else x\n    )\n    g_value.add_parse_action(lambda x: \n        [x] if len(x) &gt; 1 else x\n    )\n    g_key_value.add_parse_action(lambda x: \n        (x[0], x[1].as_list()) if isinstance(x[1],pp.ParseResults) else (x[0], x[1])\n    )\n    pass\n</code></pre>"},{"location":"#slides.keyvalue_parser.KeyValueParserConfig","title":"<code>KeyValueParserConfig</code>  <code>dataclass</code>","text":"<p>a configuration for a key/value Parser</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>@dataclass\nclass KeyValueParserConfig():\n    \"\"\"\n    a configuration for a key/value Parser\n    \"\"\"\n    key_value_delim:str=\":\"\n    record_delim:str=\"\u2022\"\n    value_delim:str=\",\"\n    quote:str=\"\\'\"\n    unicode_chars:str=\"\u2022\u2192\u2013\"\n    strip:bool=True\n    ignore_errors:bool=True\n    defined_keys_only:bool=False\n    debug:bool=False\n</code></pre>"},{"location":"#slides.keyvalue_parser.KeyValueSplitParser","title":"<code>KeyValueSplitParser</code>","text":"<p>               Bases: <code>BaseKeyValueParser</code></p> <p>Key / Value Parser</p> <p>see https://stackoverflow.com/questions/75266188/pyparsing-syntax-tree-from-named-value-list/75270267#75270267</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>class KeyValueSplitParser(BaseKeyValueParser):\n    \"\"\"\n    Key / Value Parser\n\n    see https://stackoverflow.com/questions/75266188/pyparsing-syntax-tree-from-named-value-list/75270267#75270267\n    \"\"\"\n\n    def getKeyValues(self,text:str)-&gt;dict:\n        \"\"\"\n        get key/value pairs from the given text using the configured keys definition\n\n        Args:\n            text(str): the text to parser\n\n        Returns:\n            dict: the resulting key-value pairs\n        \"\"\"\n        self.errors=[]   \n        result = dict()\n        if text:\n            try: \n                rsplit=Split(delim=self.config.record_delim,unicode_chars=self.config.unicode_chars)\n                records=rsplit.split(text)\n            except Exception as rsplit_ex:\n                self.add_error(f\"record split failed {rsplit_ex}\")\n                records=[]\n            for record in records:\n                key_value_split=Split(delim=self.config.key_value_delim,unicode_chars=self.config.unicode_chars)\n                key_values=key_value_split.split(record)\n                if len(key_values)!=2:\n                    self.add_error(f\"{key_values} has {len(key_values)}) elements but should have two\")\n                    continue\n                else:\n                    key_str=key_values[0]\n                    keyword=key_str.strip()\n                    values_str=key_values[1]\n                    # is the keyword defined\n                    if not keyword in self.keydefs_by_keyword:\n                        if self.config.defined_keys_only:\n                            self.add_error(f\"undefined keyword {keyword}\")\n                        key=keyword\n                        value=values_str\n                    else:\n                        keydef=self.keydefs_by_keyword[keyword]\n                        # map keyword to key\n                        key=keydef.key\n                        values_split=Split(delim=self.config.value_delim,unicode_chars=self.config.unicode_chars,keep_quotes=False)\n                        if keydef.has_list:\n                            value_list=values_split.split(values_str)\n                            value_list=self.getStrippedValues(value_list)\n                            # value is a list\n                            value=value_list\n                        else:\n                            value=values_str\n                    if self.config.strip and isinstance(value,str):\n                        value=value.strip()\n                result[key]=value\n            self.handleErrors(text)    \n        return result\n</code></pre>"},{"location":"#slides.keyvalue_parser.KeyValueSplitParser.getKeyValues","title":"<code>getKeyValues(text)</code>","text":"<p>get key/value pairs from the given text using the configured keys definition</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the text to parser</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the resulting key-value pairs</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def getKeyValues(self,text:str)-&gt;dict:\n    \"\"\"\n    get key/value pairs from the given text using the configured keys definition\n\n    Args:\n        text(str): the text to parser\n\n    Returns:\n        dict: the resulting key-value pairs\n    \"\"\"\n    self.errors=[]   \n    result = dict()\n    if text:\n        try: \n            rsplit=Split(delim=self.config.record_delim,unicode_chars=self.config.unicode_chars)\n            records=rsplit.split(text)\n        except Exception as rsplit_ex:\n            self.add_error(f\"record split failed {rsplit_ex}\")\n            records=[]\n        for record in records:\n            key_value_split=Split(delim=self.config.key_value_delim,unicode_chars=self.config.unicode_chars)\n            key_values=key_value_split.split(record)\n            if len(key_values)!=2:\n                self.add_error(f\"{key_values} has {len(key_values)}) elements but should have two\")\n                continue\n            else:\n                key_str=key_values[0]\n                keyword=key_str.strip()\n                values_str=key_values[1]\n                # is the keyword defined\n                if not keyword in self.keydefs_by_keyword:\n                    if self.config.defined_keys_only:\n                        self.add_error(f\"undefined keyword {keyword}\")\n                    key=keyword\n                    value=values_str\n                else:\n                    keydef=self.keydefs_by_keyword[keyword]\n                    # map keyword to key\n                    key=keydef.key\n                    values_split=Split(delim=self.config.value_delim,unicode_chars=self.config.unicode_chars,keep_quotes=False)\n                    if keydef.has_list:\n                        value_list=values_split.split(values_str)\n                        value_list=self.getStrippedValues(value_list)\n                        # value is a list\n                        value=value_list\n                    else:\n                        value=values_str\n                if self.config.strip and isinstance(value,str):\n                    value=value.strip()\n            result[key]=value\n        self.handleErrors(text)    \n    return result\n</code></pre>"},{"location":"#slides.keyvalue_parser.Keydef","title":"<code>Keydef</code>  <code>dataclass</code>","text":"<p>a key definition</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>@dataclass\nclass Keydef():\n    \"\"\"\n    a key definition\n    \"\"\"\n    keyword: str\n    key: str\n    has_list: bool=False\n\n    @classmethod\n    def as_dict(cls,keydefs:typing.List['Keydef'])-&gt;typing.Dict[str,'Keydef']:\n        \"\"\"\n        convert the given list of keydefs to a dict by keyword\n\n        Args:\n            keydefs(list): the list of key defs\n\n        Returns:\n            dict: a dict keyword -&gt; Keydef\n\n        \"\"\"\n        keydefs_by_keyword={}\n        for keydef in keydefs:\n            keydefs_by_keyword[keydef.keyword]=keydef\n        return keydefs_by_keyword\n</code></pre>"},{"location":"#slides.keyvalue_parser.Keydef.as_dict","title":"<code>as_dict(keydefs)</code>  <code>classmethod</code>","text":"<p>convert the given list of keydefs to a dict by keyword</p> <p>Parameters:</p> Name Type Description Default <code>keydefs(list)</code> <p>the list of key defs</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Keydef]</code> <p>a dict keyword -&gt; Keydef</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>@classmethod\ndef as_dict(cls,keydefs:typing.List['Keydef'])-&gt;typing.Dict[str,'Keydef']:\n    \"\"\"\n    convert the given list of keydefs to a dict by keyword\n\n    Args:\n        keydefs(list): the list of key defs\n\n    Returns:\n        dict: a dict keyword -&gt; Keydef\n\n    \"\"\"\n    keydefs_by_keyword={}\n    for keydef in keydefs:\n        keydefs_by_keyword[keydef.keyword]=keydef\n    return keydefs_by_keyword\n</code></pre>"},{"location":"#slides.keyvalue_parser.SimpleKeyValueParser","title":"<code>SimpleKeyValueParser</code>","text":"<p>               Bases: <code>BaseKeyValueParser</code></p> <p>a simple key value parser (which won't handle quote properly)</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>class SimpleKeyValueParser(BaseKeyValueParser):\n    \"\"\"\n    a simple key value parser (which won't handle quote properly)\n    \"\"\"\n\n    def getKeyValues(self,text:str)-&gt;dict:\n        \"\"\"\n        get key/value pairs from the given text using the configured keys definition\n\n        Args:\n            text(str): the text to parser\n\n        Returns:\n            dict: the resulting key-value pairs\n        \"\"\" \n        result={}\n        self.errors=[]\n        if text:\n            key_values=text.split(self.config.record_delim)\n            for key_value in key_values:\n                if not self.config.key_value_delim in key_value:\n                    error_msg=f\"missing key_value delimiter '{self.config.key_value_delim} in {key_value}\"\n                    self.add_error(error_msg)\n                    if self.config.ignore_errors:\n                        continue\n                parts=key_value.split(self.config.key_value_delim)\n                if len(parts)&gt;2:\n                    error_msg=(f\"notes syntax error: {key_value} has {len(parts)}) elements but should have two\")\n                    self.add_error(error_msg)\n                    break\n                # parsed key and value\n                pkey,value=parts[0],parts[1]\n                pkey=pkey.strip()\n                if self.config.strip:\n                    value=value.strip()\n                if pkey in self.keydefs_by_keyword:\n                    keydef=self.keydefs_by_keyword[pkey]\n                    key=keydef.key\n                    if keydef.has_list:\n                        value_list=value.split(self.config.value_delim)\n                        value_list=self.getStrippedValues(value_list)\n                        # value is a list\n                        value=value_list\n                else:\n                    if self.config.defined_keys_only:\n                        error_msg=f\"undefined key {pkey}\"\n                        self.add_error(error_msg)\n                    else:\n                        key=pkey\n                result[key]=value \n                self.handleErrors(text)\n        return result\n</code></pre>"},{"location":"#slides.keyvalue_parser.SimpleKeyValueParser.getKeyValues","title":"<code>getKeyValues(text)</code>","text":"<p>get key/value pairs from the given text using the configured keys definition</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the text to parser</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the resulting key-value pairs</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def getKeyValues(self,text:str)-&gt;dict:\n    \"\"\"\n    get key/value pairs from the given text using the configured keys definition\n\n    Args:\n        text(str): the text to parser\n\n    Returns:\n        dict: the resulting key-value pairs\n    \"\"\" \n    result={}\n    self.errors=[]\n    if text:\n        key_values=text.split(self.config.record_delim)\n        for key_value in key_values:\n            if not self.config.key_value_delim in key_value:\n                error_msg=f\"missing key_value delimiter '{self.config.key_value_delim} in {key_value}\"\n                self.add_error(error_msg)\n                if self.config.ignore_errors:\n                    continue\n            parts=key_value.split(self.config.key_value_delim)\n            if len(parts)&gt;2:\n                error_msg=(f\"notes syntax error: {key_value} has {len(parts)}) elements but should have two\")\n                self.add_error(error_msg)\n                break\n            # parsed key and value\n            pkey,value=parts[0],parts[1]\n            pkey=pkey.strip()\n            if self.config.strip:\n                value=value.strip()\n            if pkey in self.keydefs_by_keyword:\n                keydef=self.keydefs_by_keyword[pkey]\n                key=keydef.key\n                if keydef.has_list:\n                    value_list=value.split(self.config.value_delim)\n                    value_list=self.getStrippedValues(value_list)\n                    # value is a list\n                    value=value_list\n            else:\n                if self.config.defined_keys_only:\n                    error_msg=f\"undefined key {pkey}\"\n                    self.add_error(error_msg)\n                else:\n                    key=pkey\n            result[key]=value \n            self.handleErrors(text)\n    return result\n</code></pre>"},{"location":"#slides.keyvalue_parser.Split","title":"<code>Split</code>","text":"<p>quoted string splitter</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>class Split():\n    \"\"\"\n    quoted string splitter\n    \"\"\"\n\n    def __init__(self,delim:str=',',quote:str=\"'\",unicode_chars:str=\"\u2022\u2192\u2013\",keep_quotes:bool=True):\n        \"\"\"\n        constructor\n\n        Args:\n            delim(str): the delimiter char, default comma\n            quote(str): the quote char, default single quote\n            unicode_chars(str): unicode characters to allow\n            keep_quotes(str): if True keep the quoted strings if False remove quotes\n\n        \"\"\"\n        self.delim=delim\n        self.quote=quote\n        self.keep_quotes=keep_quotes\n        pp.ParserElement.setDefaultWhitespaceChars(\"\")\n        self.g_quoted=pp.QuotedString(quote_char=quote)\n        self.g_value = pp.OneOrMore(pp.Word(pp.printables+unicode_chars+\" \", excludeChars=delim+quote) | self.g_quoted)\n        self.g_quoted.add_parse_action(lambda x:\n            f\"{quote}{x[0]}{quote}\" if self.keep_quotes else f\"{x[0]}\"\n        )\n        self.g_value.add_parse_action(lambda x: \n            \"\".join(x) if len(x) &gt; 1 else x\n        )  \n        self.g_split = pp.delimited_list(self.g_value, delim=delim)\n        pass\n\n    def split(self,text:str,)-&gt;list:\n        \"\"\"\n        split the given text with my delim acknowleding my quote char for quoted strings\n\n        Args:\n            text(str): the text to split\n\n        Returns:\n            list: a list of strings\n        \"\"\"\n        parse_result=self.g_split.parse_string(text, parse_all=True)\n        result_list=parse_result.asList()\n        return result_list\n</code></pre>"},{"location":"#slides.keyvalue_parser.Split.__init__","title":"<code>__init__(delim=',', quote=\"'\", unicode_chars='\u2022\u2192\u2013', keep_quotes=True)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>delim(str)</code> <p>the delimiter char, default comma</p> required <code>quote(str)</code> <p>the quote char, default single quote</p> required <code>unicode_chars(str)</code> <p>unicode characters to allow</p> required <code>keep_quotes(str)</code> <p>if True keep the quoted strings if False remove quotes</p> required Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def __init__(self,delim:str=',',quote:str=\"'\",unicode_chars:str=\"\u2022\u2192\u2013\",keep_quotes:bool=True):\n    \"\"\"\n    constructor\n\n    Args:\n        delim(str): the delimiter char, default comma\n        quote(str): the quote char, default single quote\n        unicode_chars(str): unicode characters to allow\n        keep_quotes(str): if True keep the quoted strings if False remove quotes\n\n    \"\"\"\n    self.delim=delim\n    self.quote=quote\n    self.keep_quotes=keep_quotes\n    pp.ParserElement.setDefaultWhitespaceChars(\"\")\n    self.g_quoted=pp.QuotedString(quote_char=quote)\n    self.g_value = pp.OneOrMore(pp.Word(pp.printables+unicode_chars+\" \", excludeChars=delim+quote) | self.g_quoted)\n    self.g_quoted.add_parse_action(lambda x:\n        f\"{quote}{x[0]}{quote}\" if self.keep_quotes else f\"{x[0]}\"\n    )\n    self.g_value.add_parse_action(lambda x: \n        \"\".join(x) if len(x) &gt; 1 else x\n    )  \n    self.g_split = pp.delimited_list(self.g_value, delim=delim)\n    pass\n</code></pre>"},{"location":"#slides.keyvalue_parser.Split.split","title":"<code>split(text)</code>","text":"<p>split the given text with my delim acknowleding my quote char for quoted strings</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the text to split</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of strings</p> Source code in <code>slides/keyvalue_parser.py</code> <pre><code>def split(self,text:str,)-&gt;list:\n    \"\"\"\n    split the given text with my delim acknowleding my quote char for quoted strings\n\n    Args:\n        text(str): the text to split\n\n    Returns:\n        list: a list of strings\n    \"\"\"\n    parse_result=self.g_split.parse_string(text, parse_all=True)\n    result_list=parse_result.asList()\n    return result_list\n</code></pre>"},{"location":"#slides.semslides","title":"<code>semslides</code>","text":"<p>Created on 2023-02-23</p> <p>@author: wf</p>"},{"location":"#slides.semslides.SemSlides","title":"<code>SemSlides</code>","text":"<p>a semantic mediawiki for slides</p> Source code in <code>slides/semslides.py</code> <pre><code>class SemSlides():\n    \"\"\"\n    a semantic mediawiki for slides\n    \"\"\"\n\n    def __init__(self,args):\n        \"\"\"\n        constructor\n\n        Args:\n            args(Args): my command line arguments\n        \"\"\"\n        self.args=args\n\n    @classmethod\n    def getArgParser(cls,version_msg)-&gt;ArgumentParser:\n        \"\"\"\n        Setup command line argument parser\n\n        Args:\n            description(str): the description\n            version_msg(str): the version message\n\n        Returns:\n            ArgumentParser: the argument parser\n        \"\"\"\n        parser = ArgumentParser(description=Version.description, formatter_class=RawDescriptionHelpFormatter)\n        parser.add_argument(\"-a\",\"--about\",help=\"show about info [default: %(default)s]\",action=\"store_true\")\n        parser.add_argument('--context', default=\"MetaModel\",help='context to generate from [default: %(default)s]')\n        parser.add_argument(\"-d\", \"--debug\", dest=\"debug\", action=\"store_true\", help=\"show debug info\")\n        parser.add_argument('-V', '--version', action='version', version=version_msg)\n        parser.add_argument('--wikiId', default=\"wiki\",help='id of the wiki to generate for [default: %(default)s]')\n        return parser\n</code></pre>"},{"location":"#slides.semslides.SemSlides.__init__","title":"<code>__init__(args)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>args(Args)</code> <p>my command line arguments</p> required Source code in <code>slides/semslides.py</code> <pre><code>def __init__(self,args):\n    \"\"\"\n    constructor\n\n    Args:\n        args(Args): my command line arguments\n    \"\"\"\n    self.args=args\n</code></pre>"},{"location":"#slides.semslides.SemSlides.getArgParser","title":"<code>getArgParser(version_msg)</code>  <code>classmethod</code>","text":"<p>Setup command line argument parser</p> <p>Parameters:</p> Name Type Description Default <code>description(str)</code> <p>the description</p> required <code>version_msg(str)</code> <p>the version message</p> required <p>Returns:</p> Name Type Description <code>ArgumentParser</code> <code>ArgumentParser</code> <p>the argument parser</p> Source code in <code>slides/semslides.py</code> <pre><code>@classmethod\ndef getArgParser(cls,version_msg)-&gt;ArgumentParser:\n    \"\"\"\n    Setup command line argument parser\n\n    Args:\n        description(str): the description\n        version_msg(str): the version message\n\n    Returns:\n        ArgumentParser: the argument parser\n    \"\"\"\n    parser = ArgumentParser(description=Version.description, formatter_class=RawDescriptionHelpFormatter)\n    parser.add_argument(\"-a\",\"--about\",help=\"show about info [default: %(default)s]\",action=\"store_true\")\n    parser.add_argument('--context', default=\"MetaModel\",help='context to generate from [default: %(default)s]')\n    parser.add_argument(\"-d\", \"--debug\", dest=\"debug\", action=\"store_true\", help=\"show debug info\")\n    parser.add_argument('-V', '--version', action='version', version=version_msg)\n    parser.add_argument('--wikiId', default=\"wiki\",help='id of the wiki to generate for [default: %(default)s]')\n    return parser\n</code></pre>"},{"location":"#slides.semslides.main","title":"<code>main(argv=None)</code>","text":"<p>main routine</p> Source code in <code>slides/semslides.py</code> <pre><code>def main(argv=None):\n    '''\n    main routine\n    '''\n    if argv is None:\n        argv = sys.argv   \n    program_name = os.path.basename(sys.argv[0])#\n\n\n    debug=True\n    try:\n        program_version_message = f'{program_name} (v{Version.version},{Version.updated})'\n        parser=SemSlides.getArgParser(program_version_message)\n        args = parser.parse_args(argv[1:])\n        semSlides=SemSlides(args)\n        if args.about:\n            print(program_version_message)\n            print(f\"see {Version.doc_url}\")\n            webbrowser.open(Version.doc_url)\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if debug:\n            print(traceback.format_exc())\n        return 2     \n</code></pre>"},{"location":"#slides.slidewalker","title":"<code>slidewalker</code>","text":"<p>Created on 2022-04-07</p> <p>@author: wf</p>"},{"location":"#slides.slidewalker.PPT","title":"<code>PPT</code>","text":"<p>               Bases: <code>object</code></p> <p>PowerPoint Presentation with lecture</p> Source code in <code>slides/slidewalker.py</code> <pre><code>class PPT(object):\n    '''\n    PowerPoint Presentation with lecture\n    '''\n\n    def __init__(self,filepath,pageHeight=297):\n        '''\n        Constructor\n        '''\n        self.filepath=filepath\n        self.basename=os.path.basename(filepath)\n        self.pageHeight=pageHeight\n        if not os.path.isfile(filepath):\n            raise Exception(\"%s does not exist\" % filepath)\n        self.prs=None\n        self.error=None\n        self.slides=[]\n\n    def summary(self)-&gt;str:\n        '''\n        show a summary of the given lecture\n        '''\n        if self.error:\n            summary=f\"error: {self.error} at {self.filepath}\"\n        else:\n            if hasattr(self, \"lecture\"):\n                summary=f\"{self.title}({len(self.lecture)} lecture)/{self.author}/{self.created}  {self.basename}\"\n            else:\n                summary=f\"{self.title}/{self.author}/{self.created}  {self.basename}\"\n        return summary\n\n    def asDict(self)-&gt;dict:\n        \"\"\"\n        convert me to a dict\n\n        Returns:\n            dict: summary\n        \"\"\"\n        if self.error:\n            summary={\"error\":str(self.error),\"path\":self.filepath}\n        else:\n            summary={\"title\":self.title,\"author\":self.author,\"created\":self.created,\"path\":self.filepath}\n        return summary\n\n    def open(self):\n        '''\n        open my presentation\n        '''\n        try:\n            self.prs = Presentation(self.filepath)\n            self.author=self.prs.core_properties.author\n            self.created=self.prs.core_properties.created\n            self.title=self.prs.core_properties.title\n        except Exception as ex:\n            self.error=ex\n\n    def getSlides(self, excludeHiddenSlides:bool=False,runDelim:str=None):\n        '''\n        get my slides\n\n        Args:\n            excludeHiddenSlides(bool): if True exclude hidden Slides\n        '''\n        if runDelim is None:\n            runDelim=Slide.defaultRunDelim\n        if self.prs is None:\n            self.open()\n        if not self.error:\n            page=0\n            pdf_page=0\n            for slide in self.prs.slides:\n                page+=1\n                if excludeHiddenSlides:\n                    if slide._element.get('show') == '0':\n                        # slide is hidden \u2192 go to next slide\n                        continue\n                pdf_page += 1\n                pptSlide=Slide(self,slide,page=page,pdf_page=pdf_page,runDelim=runDelim)\n                self.slides.append(pptSlide)\n        return self.slides\n</code></pre>"},{"location":"#slides.slidewalker.PPT.__init__","title":"<code>__init__(filepath, pageHeight=297)</code>","text":"<p>Constructor</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def __init__(self,filepath,pageHeight=297):\n    '''\n    Constructor\n    '''\n    self.filepath=filepath\n    self.basename=os.path.basename(filepath)\n    self.pageHeight=pageHeight\n    if not os.path.isfile(filepath):\n        raise Exception(\"%s does not exist\" % filepath)\n    self.prs=None\n    self.error=None\n    self.slides=[]\n</code></pre>"},{"location":"#slides.slidewalker.PPT.asDict","title":"<code>asDict()</code>","text":"<p>convert me to a dict</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>summary</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def asDict(self)-&gt;dict:\n    \"\"\"\n    convert me to a dict\n\n    Returns:\n        dict: summary\n    \"\"\"\n    if self.error:\n        summary={\"error\":str(self.error),\"path\":self.filepath}\n    else:\n        summary={\"title\":self.title,\"author\":self.author,\"created\":self.created,\"path\":self.filepath}\n    return summary\n</code></pre>"},{"location":"#slides.slidewalker.PPT.getSlides","title":"<code>getSlides(excludeHiddenSlides=False, runDelim=None)</code>","text":"<p>get my slides</p> <p>Parameters:</p> Name Type Description Default <code>excludeHiddenSlides(bool)</code> <p>if True exclude hidden Slides</p> required Source code in <code>slides/slidewalker.py</code> <pre><code>def getSlides(self, excludeHiddenSlides:bool=False,runDelim:str=None):\n    '''\n    get my slides\n\n    Args:\n        excludeHiddenSlides(bool): if True exclude hidden Slides\n    '''\n    if runDelim is None:\n        runDelim=Slide.defaultRunDelim\n    if self.prs is None:\n        self.open()\n    if not self.error:\n        page=0\n        pdf_page=0\n        for slide in self.prs.slides:\n            page+=1\n            if excludeHiddenSlides:\n                if slide._element.get('show') == '0':\n                    # slide is hidden \u2192 go to next slide\n                    continue\n            pdf_page += 1\n            pptSlide=Slide(self,slide,page=page,pdf_page=pdf_page,runDelim=runDelim)\n            self.slides.append(pptSlide)\n    return self.slides\n</code></pre>"},{"location":"#slides.slidewalker.PPT.open","title":"<code>open()</code>","text":"<p>open my presentation</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def open(self):\n    '''\n    open my presentation\n    '''\n    try:\n        self.prs = Presentation(self.filepath)\n        self.author=self.prs.core_properties.author\n        self.created=self.prs.core_properties.created\n        self.title=self.prs.core_properties.title\n    except Exception as ex:\n        self.error=ex\n</code></pre>"},{"location":"#slides.slidewalker.PPT.summary","title":"<code>summary()</code>","text":"<p>show a summary of the given lecture</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def summary(self)-&gt;str:\n    '''\n    show a summary of the given lecture\n    '''\n    if self.error:\n        summary=f\"error: {self.error} at {self.filepath}\"\n    else:\n        if hasattr(self, \"lecture\"):\n            summary=f\"{self.title}({len(self.lecture)} lecture)/{self.author}/{self.created}  {self.basename}\"\n        else:\n            summary=f\"{self.title}/{self.author}/{self.created}  {self.basename}\"\n    return summary\n</code></pre>"},{"location":"#slides.slidewalker.Slide","title":"<code>Slide</code>","text":"<p>               Bases: <code>object</code></p> <p>a single slide</p> Source code in <code>slides/slidewalker.py</code> <pre><code>class Slide(object):\n    '''\n    a single slide\n    '''\n    defaultRunDelim=\"\"\n\n    def __init__(self,ppt,slide,page,pdf_page,runDelim:str=None):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.ppt=ppt\n        self.slide=slide\n        self.page=page\n        self.pdf_page=pdf_page\n        self.name=slide.name\n        self.title=None\n        if runDelim is None:\n            runDelim=Slide.defaultRunDelim\n        self.runDelim=runDelim\n        # https://stackoverflow.com/a/40821359/1497139\n        if slide.shapes.title:\n            self.title=slide.shapes.title.text\n        if self.title is None:\n            self.title=self.name\n        pass\n\n    def asDict(self):\n        summary={\n            \"page\": self.page,\n            \"pdf_page\": self.pdf_page,\n            \"title\": self.title,\n            \"name\": self.name,\n            \"text\": self.getText(),\n            \"notes\": self.getNotes()\n        }\n        return summary\n\n    def summary(self):\n        text=(f\"{self.page:3d}({self.name}):{self.title}\")\n        return text\n\n    def getMM(self,emu):\n        # https://startbigthinksmall.wordpress.com/2010/01/04/points-inches-and-emus-measuring-units-in-office-open-xml/\n        if emu is None:\n            return 0\n        else:\n            return emu.mm\n\n    def getText4Shapes(self,shapes,yRange,runDelim:str=None):\n        \"\"\"\n        get the text for the given shapes in the given yRange using the given\n        run delimiter\n\n        Args:\n            shapes:\n            yRange:\n            runDelim(str): the delimiter for text runs\n        \"\"\"\n        # lines will be populated with a list of strings,\n        # one for each \"line\"  in presentation\n        lines = []\n        line=\"\"\n        delim=\"\"\n        if runDelim is None:\n            runDelim=self.runDelim\n        y=None\n        for shape in shapes:\n            if not shape.has_text_frame:\n                continue\n\n            for paragraph in shape.text_frame.paragraphs:\n                for run in paragraph.runs:\n                    line+=f\"{delim}{run.text}\"\n                    delim=runDelim\n\n            y=self.getMM(shape.top)\n            if y and YRange.isIn(yRange,y):\n                lines.append(line)\n\n            delim=\"\"\n            line=\"\"\n\n        if y and YRange.isIn(yRange,y):\n            lines.append(line)\n            return lines\n\n    def getText(self,yRange=None):\n        '''\n        get the text in the given yRange\n\n        Args:\n            yRange:\n\n        Return:\n            str: the notes for this slide\n        '''\n        text=self.getText4Shapes(self.slide.shapes,yRange,runDelim=self.runDelim)\n        return text\n\n    def getNotes(self,yRange=None,useShapes:bool=False)-&gt;str:\n        \"\"\"\n        get the notes\n\n        Return:\n            str: the notes for this slide\n        \"\"\"\n        text=\"\"\n        if self.slide.has_notes_slide:\n            notes_slide=self.slide.notes_slide\n            if useShapes:\n                text=self.getText4Shapes(notes_slide.shapes,yRange,runDelim=self.runDelim)\n            elif notes_slide.notes_text_frame:\n                text=notes_slide.notes_text_frame.text\n        return text\n\n    def getLayoutName(self)-&gt;str:\n        '''\n        get the layoutName of this slide\n        '''\n        layoutName=self.slide.slide_layout.name\n        return layoutName\n</code></pre>"},{"location":"#slides.slidewalker.Slide.__init__","title":"<code>__init__(ppt, slide, page, pdf_page, runDelim=None)</code>","text":"<p>constructor</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def __init__(self,ppt,slide,page,pdf_page,runDelim:str=None):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.ppt=ppt\n    self.slide=slide\n    self.page=page\n    self.pdf_page=pdf_page\n    self.name=slide.name\n    self.title=None\n    if runDelim is None:\n        runDelim=Slide.defaultRunDelim\n    self.runDelim=runDelim\n    # https://stackoverflow.com/a/40821359/1497139\n    if slide.shapes.title:\n        self.title=slide.shapes.title.text\n    if self.title is None:\n        self.title=self.name\n    pass\n</code></pre>"},{"location":"#slides.slidewalker.Slide.getLayoutName","title":"<code>getLayoutName()</code>","text":"<p>get the layoutName of this slide</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def getLayoutName(self)-&gt;str:\n    '''\n    get the layoutName of this slide\n    '''\n    layoutName=self.slide.slide_layout.name\n    return layoutName\n</code></pre>"},{"location":"#slides.slidewalker.Slide.getNotes","title":"<code>getNotes(yRange=None, useShapes=False)</code>","text":"<p>get the notes</p> Return <p>str: the notes for this slide</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def getNotes(self,yRange=None,useShapes:bool=False)-&gt;str:\n    \"\"\"\n    get the notes\n\n    Return:\n        str: the notes for this slide\n    \"\"\"\n    text=\"\"\n    if self.slide.has_notes_slide:\n        notes_slide=self.slide.notes_slide\n        if useShapes:\n            text=self.getText4Shapes(notes_slide.shapes,yRange,runDelim=self.runDelim)\n        elif notes_slide.notes_text_frame:\n            text=notes_slide.notes_text_frame.text\n    return text\n</code></pre>"},{"location":"#slides.slidewalker.Slide.getText","title":"<code>getText(yRange=None)</code>","text":"<p>get the text in the given yRange</p> <p>Parameters:</p> Name Type Description Default <code>yRange</code> <code>None</code> Return <p>str: the notes for this slide</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def getText(self,yRange=None):\n    '''\n    get the text in the given yRange\n\n    Args:\n        yRange:\n\n    Return:\n        str: the notes for this slide\n    '''\n    text=self.getText4Shapes(self.slide.shapes,yRange,runDelim=self.runDelim)\n    return text\n</code></pre>"},{"location":"#slides.slidewalker.Slide.getText4Shapes","title":"<code>getText4Shapes(shapes, yRange, runDelim=None)</code>","text":"<p>get the text for the given shapes in the given yRange using the given run delimiter</p> <p>Parameters:</p> Name Type Description Default <code>shapes</code> required <code>yRange</code> required <code>runDelim(str)</code> <p>the delimiter for text runs</p> required Source code in <code>slides/slidewalker.py</code> <pre><code>def getText4Shapes(self,shapes,yRange,runDelim:str=None):\n    \"\"\"\n    get the text for the given shapes in the given yRange using the given\n    run delimiter\n\n    Args:\n        shapes:\n        yRange:\n        runDelim(str): the delimiter for text runs\n    \"\"\"\n    # lines will be populated with a list of strings,\n    # one for each \"line\"  in presentation\n    lines = []\n    line=\"\"\n    delim=\"\"\n    if runDelim is None:\n        runDelim=self.runDelim\n    y=None\n    for shape in shapes:\n        if not shape.has_text_frame:\n            continue\n\n        for paragraph in shape.text_frame.paragraphs:\n            for run in paragraph.runs:\n                line+=f\"{delim}{run.text}\"\n                delim=runDelim\n\n        y=self.getMM(shape.top)\n        if y and YRange.isIn(yRange,y):\n            lines.append(line)\n\n        delim=\"\"\n        line=\"\"\n\n    if y and YRange.isIn(yRange,y):\n        lines.append(line)\n        return lines\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker","title":"<code>SlideWalker</code>","text":"<p>               Bases: <code>object</code></p> <p>get meta information for all powerpoint presentations in a certain folder</p> Source code in <code>slides/slidewalker.py</code> <pre><code>class SlideWalker(object):\n    '''\n    get meta information for all powerpoint presentations in a certain folder\n    '''\n\n    def __init__(self, rootFolder:str, debug:bool=False):\n        '''\n        Constructor\n\n        Args:\n            rootFolder(str): the path to the root folder of the analysis\n            debug(bool): if True switch on debugging\n        '''\n        self.rootFolder=rootFolder\n        self.debug=debug\n\n    def asCsv(self,listOfDicts:list,fieldNames:list=None)-&gt;str:\n        ''' convert the given list of dicts to CSV\n        see https://stackoverflow.com/a/9157370/1497139\n\n        Args:\n            listOfDicts(list): the table to convert\n\n        Returns:\n            str: the CSV formated result\n        '''\n        output=io.StringIO()\n        if fieldNames is None:\n            fieldNameSet=set()\n            for record in listOfDicts:\n                for key in record.keys():\n                    fieldNameSet.add(key)\n            fieldNames=list(fieldNameSet)\n        writer=csv.DictWriter(output,fieldnames=fieldNames,quoting=csv.QUOTE_NONNUMERIC)\n        writer.writeheader()\n        for record in listOfDicts:\n            writer.writerow(record)\n        return output.getvalue()\n\n    def yieldPowerPointFiles(self,verbose:bool=False):\n        \"\"\"\n        generate  my power point files\n\n        Args:\n            verbose(bool): if True show information about the processing\n        \"\"\"\n        pptxFiles=self.findFiles(self.rootFolder, \".pptx\")\n        if verbose:\n            print(f\"found {len(pptxFiles)} powerpoint files\")\n        for pptxFile in pptxFiles:\n            if verbose:\n                print(f\"Extracting data from {pptxFile}\")\n            ppt=PPT(pptxFile)\n            ppt.open()\n            if not ppt.error:\n                yield ppt\n\n    def yieldSlides(self,ppt,verbose:bool, excludeHiddenSlides:bool=False, runDelim:str=None,slideDetails:bool=False):\n        \"\"\"\n        yield all slides\n\n        Args:\n            verbose(bool): if True print details on stdout\n            excludeHiddenSlides(bool): If True hidden lecture will be excluded and also ignored in the page counting\n            runDelim(str): the delimiter to use for powerpoint slide text\n        \"\"\"\n        ppt.getSlides(excludeHiddenSlides=excludeHiddenSlides,runDelim=runDelim)\n        for slide in ppt.slides:\n            if verbose and slideDetails:\n                print(slide.summary())\n            yield slide\n\n    def dumpInfo(self,outputFormat:str, excludeHiddenSlides:bool=False, runDelim:str=None, slideDetails:bool=False):\n        '''\n        dump information about the lecture in the given format\n\n        Args:\n            outputFormat(str): csv, json or txt\n            excludeHiddenSlides(bool): If True hidden lecture will be excluded and also ignored in the page counting\n            runDelim(str): the delimiter to use for powerpoint slide text\n        '''\n        info={}\n        csvRecords=[]\n        verbose=self.debug or outputFormat==\"txt\"\n        for ppt in self.yieldPowerPointFiles(verbose):\n            pptSummary=ppt.asDict()\n            if verbose:\n                print (f\"{ppt.summary()}\")\n            slideSummary=[]\n            for slide in self.yieldSlides(ppt,verbose, excludeHiddenSlides, runDelim,slideDetails=slideDetails):\n                slideRecord=slide.asDict()\n                csvRecord = OrderedDict()\n                csvRecord[\"basename\"]=ppt.basename\n                csvRecord[\"page\"]=slideRecord[\"page\"]\n                csvRecord[\"name\"]=slideRecord[\"name\"]\n                title=''.join(slideRecord[\"title\"].split())\n                csvRecord[\"title\"]=title\n                csvRecords.append(csvRecord)\n                slideSummary.append(slideRecord)\n            pptSummary[\"slides\"]=slideSummary\n            info[ppt.basename]=pptSummary\n        if outputFormat==\"json\":\n            #\n            # avoid the windows horror story\n            # https://stackoverflow.com/questions/9233027/unicodedecodeerror-charmap-codec-cant-decode-byte-x-in-position-y-character\n            # https://stackoverflow.com/a/18337754/1497139\n            jsonStr=json.dumps(info,indent=2,default=str,ensure_ascii=False).encode('utf8')\n            print(jsonStr.decode(\"utf-8\"))\n        elif outputFormat==\"csv\":\n            sortedCsvRecords=sorted(csvRecords, key = lambda row: (row[\"basename\"], int(row[\"page\"])))\n            csvText=self.asCsv(sortedCsvRecords,[\"basename\",\"page\",\"name\",\"title\"])\n            print(csvText)\n        elif outputFormat==\"lod\":\n            return info\n\n    def dumpInfoToString(self,outputFormat:str, excludeHiddenSlides:bool=True):\n        \"\"\"\n        dump information about the presentations in the given format\n\n        Args:\n            outputFormat(str): csv, json or txt\n            excludeHiddenSlides(bool): If True hidden lecture will be excluded and also ignored in the page counting\n        \"\"\"\n        f = StringIO()\n        with redirect_stdout(f):\n            self.dumpInfo(outputFormat, excludeHiddenSlides=excludeHiddenSlides)\n        stdout = f.getvalue()\n        return stdout\n\n    def findFiles(self,path:str,ext:str)-&gt;list:\n        '''\n        find Files with the given extension in the given path\n\n        Args:\n            path(str): the path to start with\n            ext(str): the extension to search for\n\n        Returns:\n            list: a list of files found\n        '''\n        foundFiles=[]\n        for root, _dirs, files in os.walk(path, topdown=False):\n            for name in files:\n                if name.endswith(ext) and not name.startswith(\"~$\"):\n                    filepath=os.path.join(root, name)\n                    foundFiles.append(filepath)\n        return foundFiles\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker.__init__","title":"<code>__init__(rootFolder, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>rootFolder(str)</code> <p>the path to the root folder of the analysis</p> required <code>debug(bool)</code> <p>if True switch on debugging</p> required Source code in <code>slides/slidewalker.py</code> <pre><code>def __init__(self, rootFolder:str, debug:bool=False):\n    '''\n    Constructor\n\n    Args:\n        rootFolder(str): the path to the root folder of the analysis\n        debug(bool): if True switch on debugging\n    '''\n    self.rootFolder=rootFolder\n    self.debug=debug\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker.asCsv","title":"<code>asCsv(listOfDicts, fieldNames=None)</code>","text":"<p>convert the given list of dicts to CSV see https://stackoverflow.com/a/9157370/1497139</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts(list)</code> <p>the table to convert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the CSV formated result</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def asCsv(self,listOfDicts:list,fieldNames:list=None)-&gt;str:\n    ''' convert the given list of dicts to CSV\n    see https://stackoverflow.com/a/9157370/1497139\n\n    Args:\n        listOfDicts(list): the table to convert\n\n    Returns:\n        str: the CSV formated result\n    '''\n    output=io.StringIO()\n    if fieldNames is None:\n        fieldNameSet=set()\n        for record in listOfDicts:\n            for key in record.keys():\n                fieldNameSet.add(key)\n        fieldNames=list(fieldNameSet)\n    writer=csv.DictWriter(output,fieldnames=fieldNames,quoting=csv.QUOTE_NONNUMERIC)\n    writer.writeheader()\n    for record in listOfDicts:\n        writer.writerow(record)\n    return output.getvalue()\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker.dumpInfo","title":"<code>dumpInfo(outputFormat, excludeHiddenSlides=False, runDelim=None, slideDetails=False)</code>","text":"<p>dump information about the lecture in the given format</p> <p>Parameters:</p> Name Type Description Default <code>outputFormat(str)</code> <p>csv, json or txt</p> required <code>excludeHiddenSlides(bool)</code> <p>If True hidden lecture will be excluded and also ignored in the page counting</p> required <code>runDelim(str)</code> <p>the delimiter to use for powerpoint slide text</p> required Source code in <code>slides/slidewalker.py</code> <pre><code>def dumpInfo(self,outputFormat:str, excludeHiddenSlides:bool=False, runDelim:str=None, slideDetails:bool=False):\n    '''\n    dump information about the lecture in the given format\n\n    Args:\n        outputFormat(str): csv, json or txt\n        excludeHiddenSlides(bool): If True hidden lecture will be excluded and also ignored in the page counting\n        runDelim(str): the delimiter to use for powerpoint slide text\n    '''\n    info={}\n    csvRecords=[]\n    verbose=self.debug or outputFormat==\"txt\"\n    for ppt in self.yieldPowerPointFiles(verbose):\n        pptSummary=ppt.asDict()\n        if verbose:\n            print (f\"{ppt.summary()}\")\n        slideSummary=[]\n        for slide in self.yieldSlides(ppt,verbose, excludeHiddenSlides, runDelim,slideDetails=slideDetails):\n            slideRecord=slide.asDict()\n            csvRecord = OrderedDict()\n            csvRecord[\"basename\"]=ppt.basename\n            csvRecord[\"page\"]=slideRecord[\"page\"]\n            csvRecord[\"name\"]=slideRecord[\"name\"]\n            title=''.join(slideRecord[\"title\"].split())\n            csvRecord[\"title\"]=title\n            csvRecords.append(csvRecord)\n            slideSummary.append(slideRecord)\n        pptSummary[\"slides\"]=slideSummary\n        info[ppt.basename]=pptSummary\n    if outputFormat==\"json\":\n        #\n        # avoid the windows horror story\n        # https://stackoverflow.com/questions/9233027/unicodedecodeerror-charmap-codec-cant-decode-byte-x-in-position-y-character\n        # https://stackoverflow.com/a/18337754/1497139\n        jsonStr=json.dumps(info,indent=2,default=str,ensure_ascii=False).encode('utf8')\n        print(jsonStr.decode(\"utf-8\"))\n    elif outputFormat==\"csv\":\n        sortedCsvRecords=sorted(csvRecords, key = lambda row: (row[\"basename\"], int(row[\"page\"])))\n        csvText=self.asCsv(sortedCsvRecords,[\"basename\",\"page\",\"name\",\"title\"])\n        print(csvText)\n    elif outputFormat==\"lod\":\n        return info\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker.dumpInfoToString","title":"<code>dumpInfoToString(outputFormat, excludeHiddenSlides=True)</code>","text":"<p>dump information about the presentations in the given format</p> <p>Parameters:</p> Name Type Description Default <code>outputFormat(str)</code> <p>csv, json or txt</p> required <code>excludeHiddenSlides(bool)</code> <p>If True hidden lecture will be excluded and also ignored in the page counting</p> required Source code in <code>slides/slidewalker.py</code> <pre><code>def dumpInfoToString(self,outputFormat:str, excludeHiddenSlides:bool=True):\n    \"\"\"\n    dump information about the presentations in the given format\n\n    Args:\n        outputFormat(str): csv, json or txt\n        excludeHiddenSlides(bool): If True hidden lecture will be excluded and also ignored in the page counting\n    \"\"\"\n    f = StringIO()\n    with redirect_stdout(f):\n        self.dumpInfo(outputFormat, excludeHiddenSlides=excludeHiddenSlides)\n    stdout = f.getvalue()\n    return stdout\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker.findFiles","title":"<code>findFiles(path, ext)</code>","text":"<p>find Files with the given extension in the given path</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to start with</p> required <code>ext(str)</code> <p>the extension to search for</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of files found</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def findFiles(self,path:str,ext:str)-&gt;list:\n    '''\n    find Files with the given extension in the given path\n\n    Args:\n        path(str): the path to start with\n        ext(str): the extension to search for\n\n    Returns:\n        list: a list of files found\n    '''\n    foundFiles=[]\n    for root, _dirs, files in os.walk(path, topdown=False):\n        for name in files:\n            if name.endswith(ext) and not name.startswith(\"~$\"):\n                filepath=os.path.join(root, name)\n                foundFiles.append(filepath)\n    return foundFiles\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker.yieldPowerPointFiles","title":"<code>yieldPowerPointFiles(verbose=False)</code>","text":"<p>generate  my power point files</p> <p>Parameters:</p> Name Type Description Default <code>verbose(bool)</code> <p>if True show information about the processing</p> required Source code in <code>slides/slidewalker.py</code> <pre><code>def yieldPowerPointFiles(self,verbose:bool=False):\n    \"\"\"\n    generate  my power point files\n\n    Args:\n        verbose(bool): if True show information about the processing\n    \"\"\"\n    pptxFiles=self.findFiles(self.rootFolder, \".pptx\")\n    if verbose:\n        print(f\"found {len(pptxFiles)} powerpoint files\")\n    for pptxFile in pptxFiles:\n        if verbose:\n            print(f\"Extracting data from {pptxFile}\")\n        ppt=PPT(pptxFile)\n        ppt.open()\n        if not ppt.error:\n            yield ppt\n</code></pre>"},{"location":"#slides.slidewalker.SlideWalker.yieldSlides","title":"<code>yieldSlides(ppt, verbose, excludeHiddenSlides=False, runDelim=None, slideDetails=False)</code>","text":"<p>yield all slides</p> <p>Parameters:</p> Name Type Description Default <code>verbose(bool)</code> <p>if True print details on stdout</p> required <code>excludeHiddenSlides(bool)</code> <p>If True hidden lecture will be excluded and also ignored in the page counting</p> required <code>runDelim(str)</code> <p>the delimiter to use for powerpoint slide text</p> required Source code in <code>slides/slidewalker.py</code> <pre><code>def yieldSlides(self,ppt,verbose:bool, excludeHiddenSlides:bool=False, runDelim:str=None,slideDetails:bool=False):\n    \"\"\"\n    yield all slides\n\n    Args:\n        verbose(bool): if True print details on stdout\n        excludeHiddenSlides(bool): If True hidden lecture will be excluded and also ignored in the page counting\n        runDelim(str): the delimiter to use for powerpoint slide text\n    \"\"\"\n    ppt.getSlides(excludeHiddenSlides=excludeHiddenSlides,runDelim=runDelim)\n    for slide in ppt.slides:\n        if verbose and slideDetails:\n            print(slide.summary())\n        yield slide\n</code></pre>"},{"location":"#slides.slidewalker.YRange","title":"<code>YRange</code>","text":"<p>an Y Range</p> Source code in <code>slides/slidewalker.py</code> <pre><code>class YRange():\n    '''\n    an Y Range\n    '''\n    def __init__(self,minY=0,maxY=300):\n        self.minY=minY\n        self.maxY=maxY\n\n    @staticmethod\n    def isIn(yRange,y):\n        result=y==0 or yRange is None or (y&gt;=yRange.minY and y&lt;=yRange.maxY)\n        return result\n</code></pre>"},{"location":"#slides.slidewalker.main","title":"<code>main(argv=None)</code>","text":"<p>main routine</p> Source code in <code>slides/slidewalker.py</code> <pre><code>def main(argv=None):\n    '''\n    main routine\n    '''\n    if argv is None:\n        argv = sys.argv\n    program_name = os.path.basename(sys.argv[0])\n    program_version_message = f'{program_name} (v{Version.version},{Version.updated})'\n    try:\n        parser = argparse.ArgumentParser(description='SlideWalker - get meta information for all powerpoint presentations in a certain folder')\n        parser.add_argument(\"-a\",\"--about\",help=\"show about info [default: %(default)s]\",action=\"store_true\")\n        parser.add_argument(\"-d\", \"--debug\", dest=\"debug\", action=\"store_true\", help=\"show debug info\")\n        parser.add_argument(\"-f\", \"--format\", default=\"json\", help=\"output format to create: csv,json or txt (default: %(default)s)\")\n        parser.add_argument(\"--includeHidden\",action=\"store_true\",help=\"exclude hidden slides (default: %(default)s)\")\n        parser.add_argument(\"--rd\",\"--runDelimiter\",dest=\"runDelim\",help=\"text run delimiter (default: %(default)s) suggested: \uff3f\u21b5\u2022\",default=Slide.defaultRunDelim)\n        parser.add_argument(\"--rootPath\",default=\".\")\n        parser.add_argument('-V', '--version', action='version', version=program_version_message)\n        args = parser.parse_args(argv[1:])\n        if args.about:\n            print(program_version_message)\n            print(f\"see {Version.doc_url}\")\n            webbrowser.open(Version.doc_url)\n        else:\n            sw=SlideWalker(args.rootPath,args.debug)\n            sw.dumpInfo(args.format,excludeHiddenSlides=not args.includeHidden,runDelim=args.runDelim)\n\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if args.debug:\n            print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#slides.version","title":"<code>version</code>","text":"<p>Created on 2022-04-01</p> <p>@author: wf</p>"},{"location":"#slides.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pysotsog</p> Source code in <code>slides/version.py</code> <pre><code>class Version(object):\n    '''\n    Version handling for pysotsog\n    '''\n    name=\"pySemanticSlides\"\n    description='generate Semantic Mediawiki for a set of powerpoint presentations with semantic annotations' \n    version=slides.__version__\n    date = '2023-02-14'\n    updated = '2023-02-22'\n    authors='Wolfgang Fahl'\n    doc_url=\"https://wiki.bitplan.com/index.php/PySemanticSlides\"\n    chat_url=\"https://github.com/WolfgangFahl/pySemanticSlides/discussions\"\n    cm_url=\"https://github.com/WolfgangFahl/pySemanticSlides\"\n    license=f'''Copyright 2020-2023 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.'''\n    longDescription=f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"}]}